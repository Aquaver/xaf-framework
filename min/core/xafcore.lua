local a=require("computer")local b=require("filesystem")local c=require("term")local d=require("text")local e=require("unicode")local f={C_NAME="XAF Core",C_INSTANCE=false,C_INHERIT=false,static={CONCAT_DEFAULT=0,CONCAT_SPACE=1,CONCAT_NOSPACE=2,CONCAT_NEWLINE=3}}function f:getExecutorInstance()local g={}g.run=function(self,h,...)assert(type(h)=="function","[XAF Core] Expected FUNCTION as argument #1")local i={...}local j=h;local k={}k={pcall(j,table.unpack(i))}return table.unpack(k)end;g.runExternal=function(self,l,...)assert(type(l)=="string","[XAF Core] Expected STRING as argument #1")local m=l;local j=nil;local i={...}local k={}if b.exists(m)==true then local n=b.open(m,'r')local o=""local p=n:read(math.huge)while p do o=o..tostring(p)p=n:read(math.huge)end;n:close()j=load(o)k={pcall(j,table.unpack(i))}return table.unpack(k)else error("[XAF Error] File '"..m.."' does not exist")end end;g.stop=function(self,q)assert(type(q)=="boolean","[XAF Core] Expected BOOLEAN as argument #1")if q==true then c.clear()end;a.pushSignal("")coroutine.yield()os.exit()end;return g end;function f:getMathInstance()local g={}g.checkInteger=function(self,r)assert(type(r)=="number","[XAF Core] Expected NUMBER as argument #1")local s=math.floor(r)local t=math.ceil(r)if s==t then return true else return false end end;g.checkNatural=function(self,r,u)assert(type(r)=="number","[XAF Core] Expected NUMBER as argument #1")assert(type(u)=="boolean","[XAF Core] Expected BOOLEAN as argument #2")local s=math.floor(r)local t=math.ceil(r)if s==t then if u==true then return r>0 else return r>=0 end else return false end end;g.getAdditiveInverse=function(self,r)assert(type(r)=="number","[XAF Core] Expected NUMBER as argument #1")local v=r;local w=v*-1;return w end;g.getGreatestCommonDivisor=function(self,x,y)assert(type(x)=="number","[XAF Core] Expected NUMBER as argument #1")assert(type(y)=="number","[XAF Core] Expected NUMBER as argument #2")if g:checkInteger(x)==false or g:checkInteger(y)==false then error("[XAF Error] Greatest common divisor must be calculated on integer numbers")else local z=0;local A=x;while y~=0 do z=A%y;A=y;y=z end;return math.abs(A)end end;g.getLowestCommonMultiple=function(self,x,y)assert(type(x)=="number","[XAF Core] Expected NUMBER as argument #1")assert(type(y)=="number","[XAF Core] Expected NUMBER as argument #2")if g:checkInteger(x)==false or g:checkInteger(y)==false then error("[XAF Error] Lowest common multiple must be calculated on integer numbers")else local B=math.abs(x*y)local C=B/g:getGreatestCommonDivisor(x,y)return C end end;g.getMultiplicativeInverse=function(self,r)assert(type(r)=="number","[XAF Core] Expected NUMBER as argument #1")local v=r;local D=1/v;return D end;return g end;function f:getSecurityInstance()local g={}g.convertBinaryToHex=function(self,E,F)assert(type(E)=="string","[XAF Core] Expected STRING as argument #1")assert(type(F)=="boolean","[XAF Core] Expected BOOLEAN as argument #2")local G=E;local H=e.wlen(G)local I={string.byte(G,1,H)}local J=""local K=F;for L=1,H do J=J..string.format("%02x",I[L])end;if K==true then J=string.upper(J)end;return J end;g.getRandomHash=function(self,M,F)assert(type(M)=="number","[XAF Core] Expected NUMBER as argument #1")assert(type(F)=="boolean","[XAF Core] Expected BOOLEAN as argument #2")local N={'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'}local O=M;local P=""local Q=F;for L=1,O do P=P..N[math.random(1,16)]end;if Q==true then P=string.upper(P)end;return P end;g.getRandomUuid=function(self,F)assert(type(F)=="boolean","[XAF Core] Expected BOOLEAN as argument #1")local R={'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'}local S=""local T=""local U=F;for L=1,30 do T=T..R[math.random(1,16)]end;S=S..string.sub(T,1,8)S=S.."-"..string.sub(T,9,12)S=S.."-4"..string.sub(T,13,15)S=S.."-"..R[math.random(9,12)]..string.sub(T,16,18)S=S.."-"..string.sub(T,19,30)if U==true then S=string.upper(S)end;return S end;g.isUuid=function(self,S)assert(type(S)=="string","[XAF Core] Expected STRING as argument #1")local V=S;local W=e.wlen(S)local X="(%x%x%x%x%x%x%x%x[-]%x%x%x%x[-]%x%x%x%x[-]%x%x%x%x[-]%x%x%x%x%x%x%x%x%x%x%x%x)"local Y=false;if W==36 and string.match(V,X)==V then Y=true end;return Y end;return g end;function f:getStringInstance()local g={}g.checkControlCharacter=function(self,Z)assert(type(Z)=="string","[XAF Core] Expected STRING as argument #1")local _=Z;local a0="[\0-\31\127]"local a1=false;if string.find(_,a0)then a1=true end;return a1 end;g.checkSpecialCharacter=function(self,Z)assert(type(Z)=="string","[XAF Core] Expected STRING as argument #1")local _=Z;local a2="[\a\b\f\n\r\t\v\\\"\'/]"local a1=false;if string.find(_,a2)then a1=true end;return a1 end;g.checkWhitespace=function(self,Z)assert(type(Z)=="string","[XAF Core] Expected STRING as argument #1")local _=Z;local a3="[\n\r\t\v ]"local a1=false;if string.find(_,a3)then a1=true end;return a1 end;return g end;function f:getTableInstance()local g={}g.getLength=function(self,a4)assert(type(a4)=="table","[XAF Core] Expected TABLE as argument #1")local a5=a4;local a6=0;for a7,a8 in pairs(a5)do a6=a6+1 end;return a6 end;g.loadFromFile=function(self,l)assert(type(l)=="string","[XAF Core] Expected STRING as argument #1")local a9=string.char(13,10)local aa=l;local ab={}if b.exists(aa)==true then local ac=b.open(aa,'r')local ad=''local ae=''while ae do ad=ad..ae;ae=ac:read(math.huge)end;ae=''ac:close()for af in string.gmatch(ad,"[^"..a9 .."]+")do local ag=string.find(af," = ")local a7=nil;local a8=nil;if string.sub(af,1,3)~="[#]"then if ag then local ah=string.sub(af,1,3)local ai=string.sub(af,5,ag-1)local aj=string.sub(af,ag+3,ag+5)local ak=string.sub(af,ag+7)if ah=="[S]"then a7=tostring(ai)elseif ah=="[N]"then a7=tonumber(ai)elseif ah=="[B]"then if ai=="true"then a7=true elseif ai=="false"then a7=false end elseif ah=="[?]"then else error("[XAF Error] Invalid table line syntax - invalid key marker")end;if aj=="[S]"then a8=tostring(ak)elseif aj=="[N]"then a8=tonumber(ak)elseif aj=="[B]"then if ak=="true"then a8=true elseif ak=="false"then a8=false end elseif aj=="[?]"then a8=nil else error("[XAF Error] Invalid table line syntax - invalid value marker")end;if a7 then ab[a7]=a8 end else error("[XAF Error] Invalid table data syntax - delimiter not found")end end end else error("[XAF Error] File '"..aa.."' does not exist")end;return ab end;g.saveToFile=function(self,a4,l,al)assert(type(a4)=="table","[XAF Core] Expected TABLE as argument #1")assert(type(l)=="string","[XAF Core] Expected STRING as argument #2")assert(type(al)=="boolean","[XAF Core] Expected BOOLEAN as argument #3")local am=a4;local an=l;local ao=al==true and'a'or'w'local ap=b.open(an,ao)for a7,a8 in g:sortByKey(am,false)do local aq=type(a7)local ah=''local ar=type(a8)local aj=''ah=aq=="string"and"[S]"or aq=="number"and"[N]"or aq=="boolean"and"[B]"or"[?]"aj=ar=="string"and"[S]"or ar=="number"and"[N]"or ar=="boolean"and"[B]"or"[?]"ap:write(ah..' '..tostring(a7).." = ")ap:write(aj..' '..tostring(a8)..'\n')end;ap:close()return true end;g.searchByValue=function(self,a4,a8,as)assert(type(a4)=="table","[XAF Core] Expected TABLE as argument #1")assert(type(a8)~="nil","[XAF Core] Expected ANYTHING as argument #2")assert(type(as)=="number","[XAF Core] Expected NUMBER as argument #3")local at=a4;local au=a8;local av=as;local aw={}for a7,a8 in pairs(at)do if av==0 then if a8==au then table.insert(aw,a7)end elseif av>0 then if a8>au then table.insert(aw,a7)end elseif av<0 then if a8<au then table.insert(aw,a7)end end end;return aw end;g.sortByKey=function(self,ax,ay)assert(type(ax)=="table","[XAF Core] Expected TABLE as argument #1")assert(type(ay)=="boolean","[XAF Core] Expected BOOLEAN as argument #2")local az=ax;local aA=ay;local aB={}local aC={}local aD={}local aE={}local aF=function(aG,aH)return aG<aH end;local aI=function(aG,aH)return aG>aH end;local aJ={}local aK=1;local aL=0;for a7,a8 in pairs(az)do local aq=type(a7)if aq=="number"then table.insert(aB,a7)elseif aq=="string"then table.insert(aC,a7)elseif aq=="boolean"then table.insert(aD,tostring(a7))else table.insert(aE,a7)end;aK=aK+1 end;if aA==true then table.sort(aB,aI)table.sort(aC,aI)table.sort(aD,aI)else table.sort(aB,aF)table.sort(aC,aF)table.sort(aD,aF)end;if aA==true then for a7,a8 in ipairs(aE)do table.insert(aJ,a8)end;for a7,a8 in ipairs(aD)do if a8=="true"then table.insert(aJ,true)elseif a8=="false"then table.insert(aJ,false)end end;for a7,a8 in ipairs(aC)do table.insert(aJ,a8)end;for a7,a8 in ipairs(aB)do table.insert(aJ,a8)end else for a7,a8 in ipairs(aB)do table.insert(aJ,a8)end;for a7,a8 in ipairs(aC)do table.insert(aJ,a8)end;for a7,a8 in ipairs(aD)do if a8=="true"then table.insert(aJ,true)elseif a8=="false"then table.insert(aJ,false)end end;for a7,a8 in ipairs(aE)do table.insert(aJ,a8)end end;return function()aL=aL+1;if aL<aK then local a7=aJ[aL]local a8=az[a7]return a7,a8 end end end;return g end;function f:getTextInstance()local g={}g.convertLinesToString=function(self,aM,aN)assert(type(aM)=="table","[XAF Core] Expected TABLE as argument #1")assert(type(aN)=="number","[XAF Core] Expected NUMBER as argument #2")local aO=aM;local aP=aN;local aQ=""local aR=""if aP>=0 and aP<=3 then aR=(aP==0 or aP==1)and' 'or aP==2 and''or aP==3 and'\n'for a7,a8 in pairs(aM)do aQ=aQ..tostring(a8)..aR end;aQ=string.sub(aQ,1,e.wlen(aQ)-1)return aQ else error("[XAF Error] Invalid concatenation mode")end end;g.convertStringToLines=function(self,aS,aT)assert(type(aS)=="string","[XAF Core] Expected STRING as argument #1")assert(type(aT)=="number","[XAF Core] Expected NUMBER as argument #2")local aU=aS;local aV=aT;local aM={}for aS in d.wrappedLines(aU,aV,aV)do table.insert(aM,aS)end;return aM end;g.padCenter=function(self,aS,aT)assert(type(aS)=="string","[XAF Core] Expected STRING as argument #1")assert(type(aT)=="number","[XAF Core] Expected NUMBER as argument #2")local aV=math.floor(aT)local aW=string.sub(aS,1,aV)local aX=e.wlen(aW)local aY=aV-aX;local aZ=math.floor(aY/2)local a_=aY-aZ;local b0=string.rep(" ",aZ)..aW..string.rep(" ",a_)return b0 end;g.padLeft=function(self,aS,aT)assert(type(aS)=="string","[XAF Core] Expected STRING as argument #1")assert(type(aT)=="number","[XAF Core] Expected NUMBER as argument #2")local aV=math.floor(aT)local aW=string.sub(aS,1,aV)local aX=e.wlen(aW)local aY=aV-aX;local b0=aW..string.rep(" ",aY)return b0 end;g.padRight=function(self,aS,aT)assert(type(aS)=="string","[XAF Core] Expected STRING as argument #1")assert(type(aT)=="number","[XAF Core] Expected NUMBER as argument #2")local aV=math.floor(aT)local aW=string.sub(aS,1,aV)local aX=e.wlen(aW)local aY=aV-aX;local b0=string.rep(" ",aY)..aW;return b0 end;g.split=function(self,aS,ag)assert(type(aS)=="string","[XAF Core] Expected STRING as argument #1")assert(type(ag)=="string","[XAF Core] Expected STRING as argument #2")local b1=aS;local b2=ag==''and' 'or ag;local b3={}for b4 in string.gmatch(b1,"[^"..b2 .."]+")do table.insert(b3,b4)end;return b3 end;return g end;return f
