local a=require("filesystem")local b=require("xaf/network/server")local c=require("xaf/core/xafcore")local d=c:getSecurityInstance()local e=c:getTableInstance()local f={C_NAME="Generic DNSP Server",C_INSTANCE=true,C_INHERIT=true,static={}}function f:initialize()local g=b:extend()local h=g and g.private or{}local i=g and g.public or{}h.serverPaths={}h.serverPaths["dns_root"]='/'h.serverPaths["dns_registry"]="DNS_REGISTRY"h.serverPaths["dns_registry_forward"]="REGISTRY_FORWARD"h.serverPaths["dns_registry_reverse"]="REGISTRY_REVERSE"h.doRegister=function(self,j)assert(type(j)=="table","[XAF Network] Expected TABLE as argument #1")local k=h.componentModem;local l=h.port;local m=j[3]local n=j[8]local o=j[9]local p=a.concat(h.serverPaths["dns_registry_forward"],o)local q=a.concat(h.serverPaths["dns_registry_reverse"],n)if n==nil or d:isUuid(tostring(n))==false then k.send(m,l,false,"Invalid Address")elseif o==nil then k.send(m,l,false,"Invalid Domain Name")elseif a.exists(q)==true then k.send(m,l,false,"Address Already Exists")elseif a.exists(p)==true then k.send(m,l,false,"Domain Name Already Exists")else local r={}local s={}local t=a.open(p,'w')local u=a.open(q,'w')t:write("[#] DNS Entry - Forward"..'\n'..'\n')u:write("[#] DNS Entry - Reverse"..'\n'..'\n')t:close()u:close()r["domain_target_address"]=n;r["domain_registrar_address"]=k.address;s["domain_target_name"]=o;s["domain_registrar_address"]=k.address;e:saveToFile(r,p,true)e:saveToFile(s,q,true)k.send(m,l,true,"OK")end end;h.doTranslateForward=function(self,j)assert(type(j)=="table","[XAF Network] Expected TABLE as argument #1")local k=h.componentModem;local l=h.port;local m=j[3]local v=j[8]local p=a.concat(h.serverPaths["dns_registry_forward"],v)if v==nil then k.send(m,l,false,"Invalid Domain Name")elseif a.exists(p)==false then k.send(m,l,false,"Domain Not Exists")else local r=e:loadFromFile(p)local w=r["domain_target_address"]k.send(m,l,true,"OK",w)end end;h.doTranslateReverse=function(self,j)assert(type(j)=="table","[XAF Network] Expected TABLE as argument #1")local k=h.componentModem;local l=h.port;local m=j[3]local x=j[8]local q=a.concat(h.serverPaths["dns_registry_reverse"],x)if x==nil or d:isUuid(x)==false then k.send(m,l,false,"Invalid Address")elseif a.exists(q)==false then k.send(m,l,false,"Address Not Exists")else local s=e:loadFromFile(q)local y=s["domain_target_name"]k.send(m,l,true,"OK",y)end end;h.doUnregister=function(self,j)assert(type(j)=="table","[XAF Network] Expected TABLE as argument #1")local k=h.componentModem;local l=h.port;local m=j[3]local z=j[8]local p=a.concat(h.serverPaths["dns_registry_forward"],z)local q=a.concat(h.serverPaths["dns_registry_reverse"],z)if z==nil then k.send(m,l,false,"Invalid Domain Object")elseif a.exists(p)==false and a.exists(q)==false then k.send(m,l,false,"Domain Not Exists")elseif a.exists(p)==true and a.exists(q)==true then k.send(m,l,false,"Domain Ambiguity")else if a.exists(p)==true then local r=e:loadFromFile(p)local A=a.concat(h.serverPaths["dns_registry_reverse"],r["domain_target_address"])if a.exists(A)==true then a.remove(A)end;a.remove(p)elseif a.exists(q)==true then local s=e:loadFromFile(q)local B=a.concat(h.serverPaths["dns_registry_forward"],s["domain_target_name"])if a.exists(B)==true then a.remove(B)end;a.remove(q)end;k.send(m,l,true,"OK")end end;h.prepareWorkspace=function(self,C)assert(type(C)=="string","[XAF Network] Expected STRING as argument #1")h.serverPaths["dns_root"]=C;h.serverPaths["dns_registry"]=a.concat(h.serverPaths["dns_root"],h.serverPaths["dns_registry"])h.serverPaths["dns_registry_forward"]=a.concat(h.serverPaths["dns_registry"],h.serverPaths["dns_registry_forward"])h.serverPaths["dns_registry_reverse"]=a.concat(h.serverPaths["dns_registry"],h.serverPaths["dns_registry_reverse"])if a.exists(h.serverPaths["dns_root"])==false then a.makeDirectory(h.serverPaths["dns_root"])end;if a.exists(h.serverPaths["dns_registry"])==false then a.makeDirectory(h.serverPaths["dns_registry"])end;if a.exists(h.serverPaths["dns_registry_forward"])==false then a.makeDirectory(h.serverPaths["dns_registry_forward"])end;if a.exists(h.serverPaths["dns_registry_reverse"])==false then a.makeDirectory(h.serverPaths["dns_registry_reverse"])end;return true end;i.process=function(self,j)assert(type(j)=="table","[XAF Network] Expected TABLE as argument #1")local k=h.componentModem;local l=h.port;local D=k.address;if h.active==true then if k then if j[1]=="modem_message"then if j[2]==D and j[4]==l then local E=j[6]local F=_G._XAF._VERSION;local m=j[3]local G=j[4]local H=j[7]if E==F then if H=="DNS_REGISTER"then return true,h:doRegister(j)elseif H=="DNS_TRANSLATE_FORWARD"then return true,h:doTranslateForward(j)elseif H=="DNS_TRANSLATE_REVERSE"then return true,h:doTranslateReverse(j)elseif H=="DNS_UNREGISTER"then return true,h:doUnregister(j)end else k.send(m,G,false,"XAF Version Mismatch")end;return false end end else error("[XAF Error] Server network modem component has not been initialized")end else error("[XAF Error] Server is already stopped")end end;return{private=h,public=i}end;function f:extend()local I=self:initialize()local h=I.private;local i=I.public;if self.C_INHERIT==true then return{private=h,public=i}else error("[XAF Error] Class '"..tostring(self.C_NAME).."' cannot be inherited")end end;function f:new(k,C)local I=self:initialize()local h=I.private;local i=I.public;i:setModem(k)assert(type(C)=="string","[XAF Network] Expected STRING as argument #2")h:prepareWorkspace(C)if self.C_INSTANCE==true then return i else error("[XAF Error] Class '"..tostring(self.C_NAME).."' cannot be instanced")end end;return f
