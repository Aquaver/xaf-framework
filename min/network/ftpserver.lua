local a=require("component")local b=require("filesystem")local c=require("xaf/network/server")local d=require("unicode")local e=require("xaf/core/xafcore")local f=e:getStringInstance()local g=e:getTableInstance()local h=e:getTextInstance()local i={C_NAME="Generic FTP Server",C_INSTANCE=true,C_INHERIT=true,static={}}function i:initialize()local j=c:extend()local k=j and j.private or{}local l=j and j.public or{}k.fileBuffer={}k.mountCounter=0;k.mountPrefix="FS:%s"k.serverPaths={}k.serverPaths["ftp_root"]='/'k.serverPaths["ftp_storage"]="FTP_STORAGE"k.workspaceMap={}k.doDirectoryCreate=function(self,m)assert(type(m)=="table","[XAF Network] Expected TABLE as argument #1")local n=k.componentModem;local o=k.port;local p=m[3]local q=b.canonical(m[8])local r=m[9]local s=b.concat(k.serverPaths["ftp_storage"],k.mountPrefix,q)local t=b.concat(s,r)local u=string.format(s,1)local v=string.format(t,1)if b.exists(u)==false then n.send(p,o,false,"Path Not Exists")elseif b.exists(v)==true then n.send(p,o,false,"Directory Already Exists")elseif b.isDirectory(u)==false then n.send(p,o,false,"Path Is Not A Directory")elseif r==nil or f:checkControlCharacter(r)==true or f:checkSpecialCharacter(r)==true or f:checkWhitespace(r)==true then n.send(p,o,false,"Invalid Directory Name")else for w=1,k.mountCounter do b.makeDirectory(string.format(t,w))end;n.send(p,o,true,"OK")end end;k.doDirectoryList=function(self,m)assert(type(m)=="table","[XAF Network] Expected TABLE as argument #1")local n=k.componentModem;local o=k.port;local p=m[3]local q=b.canonical(m[8])local s=b.concat(k.serverPaths["ftp_storage"],k.mountPrefix,q)local u=string.format(s,1)if b.exists(u)==false then n.send(p,o,false,"Path Not Exists")elseif b.isDirectory(u)==false then n.send(p,o,false,"Path Is Not A Directory")else local x={}local y={}local z='/'local A='/'for B in b.list(u)do if string.sub(B,-1,-1)=='/'then x[B]=0 else y[B]=0 end end;for C,D in g:sortByKey(x,false)do z=z..string.sub(C,1,-2)..'/'end;for C,D in g:sortByKey(y,false)do A=A..C..'/'end;n.send(p,o,true,"OK",z,A)end end;k.doFileDownloadContinue=function(self,m)assert(type(m)=="table","[XAF Network] Expected TABLE as argument #1")local n=k.componentModem;local o=k.port;local p=m[3]local E=b.canonical(m[8])local F=b.concat(k.serverPaths["ftp_storage"],k.mountPrefix,E)if k.fileBuffer[p]then if k.fileBuffer[p]["file_path"]==F then local G=k.fileBuffer[p]["file_data"][1]local H=k.fileBuffer[p]["file_data"][2]if H then table.remove(k.fileBuffer[p]["file_data"],1)n.send(p,o,true,"OK (Next)",G)else k.fileBuffer[p]=nil;n.send(p,o,true,"OK (Stop)",G)end else n.send(p,o,false,"File Buffer Already Exists")end else n.send(p,o,false,"File Buffer Not Exists")end end;k.doFileDownloadStart=function(self,m)assert(type(m)=="table","[XAF Network] Expected TABLE as argument #1")local n=k.componentModem;local o=k.port;local p=m[3]local E=b.canonical(m[8])local F=b.concat(k.serverPaths["ftp_storage"],k.mountPrefix,E)local I=string.format(F,1)if b.exists(I)==false then n.send(p,o,false,"File Not Exists")elseif b.isDirectory(I)==true then n.send(p,o,false,"Invalid File")elseif E==''or E=='/'then n.send(p,o,false,"Access Denied")else local J=19;local K=n.maxPacketSize()-J;local L=''k.fileBuffer[p]={}k.fileBuffer[p]["file_path"]=F;k.fileBuffer[p]["file_data"]={}for w=1,k.mountCounter do local M=string.format(F,w)local N=b.open(M,'r')local O=''while O do L=L..O;O=N:read(math.huge)end;N:close()end;for w=1,d.wlen(L),K do local P=w;local Q=w+K-1;local R=string.sub(L,P,Q)table.insert(k.fileBuffer[p]["file_data"],R)end;n.send(p,o,true,"OK")end end;k.doFileMove=function(self,m)assert(type(m)=="table","[XAF Network] Expected TABLE as argument #1")local n=k.componentModem;local o=k.port;local p=m[3]local S=b.canonical(m[8])local T=b.canonical(m[9])local U=b.concat(k.serverPaths["ftp_storage"],k.mountPrefix,S)local V=b.concat(k.serverPaths["ftp_storage"],k.mountPrefix,T)local W=string.format(U,1)local X=string.format(V,1)if b.exists(W)==false then n.send(p,o,false,"File Not Exists")elseif b.exists(X)==false then n.send(p,o,false,"Path Not Exists")elseif b.isDirectory(X)==false then n.send(p,o,false,"Path Is Not A Directory")elseif S==''or S=='/'then n.send(p,o,false,"Access Denied")else local Y=h:split(U,'/',true)local Z=#Y;local _=Y[Z]local a0=b.concat(V,_)for w=1,k.mountCounter do b.rename(string.format(U,w),string.format(a0,w))end;n.send(p,o,true,"OK")end end;k.doFileRemove=function(self,m)assert(type(m)=="table","[XAF Network] Expected TABLE as argument #1")local n=k.componentModem;local o=k.port;local p=m[3]local M=b.canonical(m[8])local a1=b.concat(k.serverPaths["ftp_storage"],k.mountPrefix,M)local a2=string.format(a1,1)if b.exists(a2)==false then n.send(p,o,false,"File Not Exists")elseif M==''or M=='/'then n.send(p,o,false,"Access Denied")else for w=1,k.mountCounter do b.remove(string.format(a1,w))end;n.send(p,o,true,"OK")end end;k.doFileRename=function(self,m)assert(type(m)=="table","[XAF Network] Expected TABLE as argument #1")local n=k.componentModem;local o=k.port;local p=m[3]local M=b.canonical(m[8])local a3=m[9]local a1=b.concat(k.serverPaths["ftp_storage"],k.mountPrefix,M)local a2=string.format(a1,1)if b.exists(a2)==false then n.send(p,o,false,"File Not Exists")elseif M==''or M=='/'then n.send(p,o,false,"Access Denied")elseif a3==nil or f:checkControlCharacter(a3)==true or f:checkSpecialCharacter(a3)==true or f:checkWhitespace(a3)==true then n.send(p,o,false,"Invalid File New Name")else local Y=h:split(a1,'/',true)local Z=#Y;local a0=''local a4=''for w=1,Z-1 do a0=a0 ..Y[w]a0=a0 ..'/'end;a0=a0 ..a3;a4=string.format(a0,1)if b.exists(a4)==true then n.send(p,o,false,"New Name Already Occupied")else for w=1,k.mountCounter do b.rename(string.format(a1,w),string.format(a0,w))end;n.send(p,o,true,"OK")end end end;k.doFileUploadContinue=function(self,m)assert(type(m)=="table","[XAF Network] Expected TABLE as argument #1")local n=k.componentModem;local o=k.port;local p=m[3]local q=b.canonical(m[8])local _=m[9]local a5=m[10]local s=b.concat(k.serverPaths["ftp_storage"],k.mountPrefix,q)local a1=b.concat(s,_)if k.fileBuffer[p]then if k.fileBuffer[p]["file_path"]==a1 then table.insert(k.fileBuffer[p]["file_data"],a5)n.send(p,o,true,"OK")else n.send(p,o,false,"File Buffer Already Exists")end else n.send(p,o,false,"File Buffer Not Exists")end end;k.doFileUploadStart=function(self,m)assert(type(m)=="table","[XAF Network] Expected TABLE as argument #1")local n=k.componentModem;local o=k.port;local p=m[3]local q=b.canonical(m[8])local _=m[9]local s=b.concat(k.serverPaths["ftp_storage"],k.mountPrefix,q)local a1=b.concat(s,_)local u=string.format(s,1)local a2=string.format(a1,1)if b.exists(u)==false then n.send(p,o,false,"Directory Not Exists")elseif b.exists(a2)==true then n.send(p,o,false,"File Already Exists")elseif _==nil or f:checkControlCharacter(_)==true or f:checkSpecialCharacter(_)==true or f:checkWhitespace(_)==true then n.send(p,o,false,"Invalid File Name")else for w=1,k.mountCounter do b.open(string.format(a1,w),'w'):close()end;k.fileBuffer[p]={}k.fileBuffer[p]["file_path"]=a1;k.fileBuffer[p]["file_data"]={}n.send(p,o,true,"OK")end end;k.doFileUploadStop=function(self,m)assert(type(m)=="table","[XAF Network] Expected TABLE as argument #1")local n=k.componentModem;local o=k.port;local p=m[3]local q=b.canonical(m[8])local _=m[9]local s=b.concat(k.serverPaths["ftp_storage"],k.mountPrefix,q)local a1=b.concat(s,_)if k.fileBuffer[p]then if k.fileBuffer[p]["file_path"]==a1 then local a6=k.fileBuffer[p]["file_data"]local a7=''for w=1,#a6 do a7=a7 ..a6[w]end;if d.wlen(a7)>=k.mountCounter then local a8=math.ceil(d.wlen(a7)/k.mountCounter)for w=1,k.mountCounter do local a9=string.format(a1,w)local aa=b.open(a9,'w')aa:write(string.sub(a7,1+(w-1)*a8,a8+(w-1)*a8))aa:close()end else for w=1,d.wlen(a7)do local a9=string.format(a1,w)local aa=b.open(a9,'w')aa:write(string.sub(a7,w,w))aa:close()end;for w=d.wlen(a7)+1,k.mountCounter do local a9=string.format(a1,w)local aa=b.open(a9,'w')aa:close()end end;k.fileBuffer[p]=nil;n.send(p,o,true,"OK")else n.send(p,o,false,"File Buffer Already Exists")end else n.send(p,o,false,"File Buffer Not Exists")end end;k.prepareWorkspace=function(self,ab)assert(type(ab)=="string","[XAF Network] Expected STRING as argument #1")k.serverPaths["ftp_root"]=ab;k.serverPaths["ftp_storage"]=b.concat(k.serverPaths["ftp_root"],k.serverPaths["ftp_storage"])if b.exists(k.serverPaths["ftp_root"])==false then b.makeDirectory(k.serverPaths["ftp_root"])end;if b.exists(k.serverPaths["ftp_storage"])==false then b.makeDirectory(k.serverPaths["ftp_storage"])end;return true end;k.process=function(self,m)assert(type(m)=="table","[XAF Network] Expected TABLE as argument #1")local ac=m[7]if ac=="FTP_DIRECTORY_CREATE"then return true,k:doDirectoryCreate(m)elseif ac=="FTP_DIRECTORY_LIST"then return true,k:doDirectoryList(m)elseif ac=="FTP_FILE_DOWNLOAD_CONTINUE"then return true,k:doFileDownloadContinue(m)elseif ac=="FTP_FILE_DOWNLOAD_START"then return true,k:doFileDownloadStart(m)elseif ac=="FTP_FILE_MOVE"then return true,k:doFileMove(m)elseif ac=="FTP_FILE_REMOVE"then return true,k:doFileRemove(m)elseif ac=="FTP_FILE_RENAME"then return true,k:doFileRename(m)elseif ac=="FTP_FILE_UPLOAD_CONTINUE"then return true,k:doFileUploadContinue(m)elseif ac=="FTP_FILE_UPLOAD_START"then return true,k:doFileUploadStart(m)elseif ac=="FTP_FILE_UPLOAD_STOP"then return true,k:doFileUploadStop(m)else return false end end;k.setWorkspace=function(self,ad)assert(type(ad)=="table","[XAF Network] Expected TABLE as argument #1")local ae=ad;local af={}local ag={}for C,D in pairs(ae)do af[D]=0 end;for C,D in g:sortByKey(af,false)do local ah=C;local ai=a.type(ah)if ai=="filesystem"then table.insert(ag,ah)else error("[XAF Error] Invalid filesystem component")end end;for w=1,#ag do local aj=ag[w]local ak=string.format(k.mountPrefix,w)local al=b.concat(k.serverPaths["ftp_storage"],ak)b.mount(aj,al)end;k.mountCounter=#ag;k.workspaceMap=ag;return true end;return{private=k,public=l}end;function i:extend()local am=self:initialize()local k=am.private;local l=am.public;if self.C_INHERIT==true then return{private=k,public=l}else error("[XAF Error] Class '"..tostring(self.C_NAME).."' cannot be inherited")end end;function i:new(n,ab,ad)local am=self:initialize()local k=am.private;local l=am.public;l:setModem(n)assert(type(ab)=="string","[XAF Network] Expected STRING as argument #2")k:prepareWorkspace(ab)assert(type(ad)=="table","[XAF Network] Expected TABLE as argument #3")k:setWorkspace(ad)if self.C_INSTANCE==true then return l else error("[XAF Error] Class '"..tostring(self.C_NAME).."' cannot be instanced")end end;return i
