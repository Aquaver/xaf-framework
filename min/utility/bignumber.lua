local a=require("xaf/core/xafcore")local b=a:getMathInstance()local c=a:getTableInstance()local d={C_NAME="Arbitrary Precision Number",C_INSTANCE=true,C_INHERIT=true,static={}}function d:initialize()local e=nil;local f=e and e.private or{}local g=e and e.public or{}f.decimalDigits={}f.decimalLength=0;f.decimalPrecision=-1;f.decimalPrecisionMax=10;f.integerDigits={}f.integerLength=0;f.initialExponent=0;f.numberSign=0;f.separatorDecimal='.'f.separatorThousandsDecimal=''f.separatorThousandsInteger=''f.radixMaximumValue=16;f.radixMinimumValue=2;f.radixCharacterTable={'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'}f.buildFromTable=function(self,h,i,j)assert(type(h)=="table","[XAF Utility] Expected TABLE as argument #1")assert(type(i)=="table","[XAF Utility] Expected TABLE as argument #2")assert(type(j)=="number","[XAF Utility] Expected NUMBER as argument #3")local k=d:extend()k.private.decimalDigits=h;k.private.decimalLength=#h;k.private.integerDigits=i;k.private.integerLength=#i;if j==0 or j==1 then k.private.numberSign=j;k.private:normalizeNumber()else error("[XAF Error] Invalid BigNumber sign value - must be equal to zero '0' or one '1'")end;return k.public end;f.checkPrecision=function(self,l,m,n)assert(type(l)=="table","[XAF Utility] Expected TABLE as argument #1")assert(type(m)=="table","[XAF Utility] Expected TABLE as argument #2")assert(type(n)=="number","[XAF Utility] Expected NUMBER as argument #3")if l.returnValue==nil then error("[XAF Error] Required valid BigNumber object to check precision (first)")elseif m.returnValue==nil then error("[XAF Error] Required valid BigNumber object to check precision (second)")elseif b:checkNatural(n,false)==false then error("[XAF Error] Digit count value must be natural number (including zero)")else local o='0'..f.separatorDecimal..string.rep('0',n-1)..'1'local p=d:new(o)local q=l:subtract(m)local r=q:absoluteValue()local s=r:isLower(p)return s end end;f.convertString=function(self,t)assert(type(t)=="string","[XAF Utility] Expected STRING as argument #1")local u={}local v=0;local w={}local x=0;local y=0;local z=false;local A=#t;if A==0 then error("[XAF Error] Number string for initializing BigNumber must not be empty")else local B=string.sub(t,1,1)if B=='-'then if A==1 then error("[XAF Error] Invalid string for BigNumber object - required digits after minus character")else y=1;t=string.sub(t,2)A=A-1 end end;for C=1,A do local D=string.sub(t,C,C)if tonumber(D)then if z==true then table.insert(u,tonumber(D))v=v+1 else table.insert(w,1,tonumber(D))x=x+1 end elseif D==f.separatorDecimal then if x==0 then w={0}x=1 end;if z==false then z=true else error("[XAF Error] Invalid string for BigNumber object - encountered two decimal separators")end elseif D=='e'or D=='E'then local E=''local F=0;for G=C+1,A do D=string.sub(t,G,G)if tonumber(D)or D=='+'or D=='-'then E=E..D else error("[XAF Error] Invalid string for BigNumber object - encountered non-number exponent")end end;if tonumber(E)then F=tonumber(E)f.initialExponent=F else error("[XAF Error] Invalid string for BigNumber object - encountered non-number exponent")end;break else error("[XAF Error] Invalid string for BigNumber object - encountered non-digit character")end end;f.decimalDigits=u;f.decimalLength=v;f.integerDigits=w;f.integerLength=x;f.numberSign=y;return true end end;f.convertStringRadix=function(self,t,H)assert(type(t)=="string","[XAF Utility] Expected STRING as argument #1")assert(type(H)=="number","[XAF Utility] Expected NUMBER as argument #2")local I=f.radixMaximumValue;local J=f.radixMinimumValue;local K=f.radixCharacterTable;local L=d:new(tostring(H))if b:checkInteger(H)==true and H>=J and H<=I then local u={}local v=0;local w={}local x=0;local y=0;local z=false;local A=#t;t=string.lower(t)if A==0 then error("[XAF Error] Number string for initializing BigNumber must not be empty")else local B=string.sub(t,1,1)if B=='-'then if A==1 then error("[XAF Error] Invalid string for BigNumber object - required digits after minus character")else y=1;t=string.sub(t,2)A=A-1 end end;for C=1,A do local D=string.sub(t,C,C)local M=c:searchByValue(K,D,0)local N=#M;if N==1 then if M[1]>H then error("[XAF Error] Invalid string for BigNumber object - encountered non-digit character (for this radix)")else if z==true then table.insert(u,1,D)v=v+1 else table.insert(w,1,D)x=x+1 end end elseif D==f.separatorDecimal then if x==0 then w={0}x=1 end;if z==false then z=true else error("[XAF Error] Invalid string for BigNumber object - encountered two decimal separators")end elseif N==0 then error("[XAF Error] Invalid string for BigNumber object - encountered non-digit character")else error("[XAF Error] Invalid string for BigNumber object - encountered non-digit character")end end;local O=nil;local P=d:new('0')local Q=L:power(v)local R=d:new('0')for C=1,x do local S=w[C]local T=c:searchByValue(K,S,0)local U=d:new(tostring(T[1]-1))local V=U:multiply(L:power(C-1))P=P:add(V)end;if Q:isEqual(R)==false then for C=1,v do local S=u[C]local T=c:searchByValue(K,S,0)local U=d:new(tostring(T[1]-1))local V=U:multiply(L:power(C-1))R=R:add(V)end;R:setMaxPrecision(g:getMaxPrecision())Q:setMaxPrecision(g:getMaxPrecision())P=P:add(R:divide(Q))P:setNumberSign(y)O=P:returnValue()f.decimalDigits=O.decimalDigits;f.decimalLength=O.decimalLength;f.integerDigits=O.integerDigits;f.integerLength=O.integerLength;f.numberSign=O.numberSign;return true end end else error("[XAF Error] Invalid BigNumber radix value, must be integer in range from "..J.." to "..I)end end;f.normalizeNumber=function(self)local W=f.decimalLength;local X=f.integerLength;for C=X,2,-1 do if f.integerDigits[C]==0 then table.remove(f.integerDigits,C)f.integerLength=f.integerLength-1 else break end end;for C=W,1,-1 do if f.decimalDigits[C]==0 then table.remove(f.decimalDigits,C)f.decimalLength=f.decimalLength-1 else break end end;if f.integerLength<1 then f.integerDigits={0}f.integerLength=1 end;if f.integerLength==1 and f.decimalLength==0 then if f.integerDigits[1]==0 then f.numberSign=0 end end;return true end;f.rawAdd=function(self,Y)assert(type(Y)=="table","[XAF Utility] Expected TABLE as argument #1")if Y.returnValue==nil then error("[XAF Error] Invalid BigNumber object - use instance(s) of this class only")else local Z=Y:returnValue()local _=Z.decimalDigits;local W=Z.decimalLength;local a0=Z.integerDigits;local X=Z.integerLength;local a1=Z.numberSign;if _ and W and a0 and X and a1 then local a2=f.integerLength>X and f.integerLength or X;local a3=f.decimalLength>W and f.decimalLength or W;local u={}local v=0;local w={}local x=0;local y=0;local a4=0;for C=a3,1,-1 do local a5=f.decimalDigits[C]==nil and 0 or f.decimalDigits[C]local a6=_[C]==nil and 0 or _[C]local a7=a4+a5+a6;local a8=a7%10;local a9=a7/10;if u[C]==nil then u[C]=a8;v=v+1 end;a4=math.floor(a9)end;for C=1,a2 do local aa=f.integerDigits[C]==nil and 0 or f.integerDigits[C]local ab=a0[C]==nil and 0 or a0[C]local a7=a4+aa+ab;local a8=a7%10;local a9=a7/10;if w[C]==nil then w[C]=a8;x=x+1 end;a4=math.floor(a9)end;if a4>0 then table.insert(w,a4)x=x+1 end;return f:buildFromTable(u,w,y)else error("[XAF Error] Invalid BigNumber object - use instance(s) of this class only")end end end;f.rawSubtract=function(self,Y)assert(type(Y)=="table","[XAF Utility] Expected TABLE as argument #1")if Y.returnValue==nil then error("[XAF Error] Invalid BigNumber object - use instance(s) of this class only")else local ac=g:absoluteValue()local ad=Y:absoluteValue()local Z=ad:returnValue()local _=Z.decimalDigits;local W=Z.decimalLength;local a0=Z.integerDigits;local X=Z.integerLength;local a1=Z.numberSign;if _ and W and a0 and X and a1 then local a2=f.integerLength>X and f.integerLength or X;local a3=f.decimalLength>W and f.decimalLength or W;local u={}local v=0;local w={}local x=0;local y=0;local a4=0;if ac:isEqual(ad)==true then return f:buildFromTable({},{0},0)elseif ac:isGreater(ad)==true then for C=a3,1,-1 do local a5=f.decimalDigits[C]==nil and 0 or f.decimalDigits[C]local a6=_[C]==nil and 0 or _[C]local ae=a4+a5-a6;local af=nil;if ae<0 then a4=-1;ae=ae+10;af=ae%10 else a4=0;af=ae%10 end;if u[C]==nil then u[C]=af;v=v+1 end end;for C=1,a2 do local aa=f.integerDigits[C]==nil and 0 or f.integerDigits[C]local ab=a0[C]==nil and 0 or a0[C]local ae=a4+aa-ab;local af=nil;if ae<0 then a4=-1;ae=ae+10;af=ae%10 else a4=0;af=ae%10 end;if w[C]==nil then w[C]=af;x=x+1 end end;return f:buildFromTable(u,w,y)elseif ac:isLower(ad)==true then for C=a3,1,-1 do local a5=_[C]==nil and 0 or _[C]local a6=f.decimalDigits[C]==nil and 0 or f.decimalDigits[C]local ae=a4+a5-a6;local af=nil;if ae<0 then a4=-1;ae=ae+10;af=ae%10 else a4=0;af=ae%10 end;if u[C]==nil then u[C]=af;v=v+1 end end;for C=1,a2 do local aa=a0[C]==nil and 0 or a0[C]local ab=f.integerDigits[C]==nil and 0 or f.integerDigits[C]local ae=a4+aa-ab;local af=nil;if ae<0 then a4=-1;ae=ae+10;af=ae%10 else a4=0;af=ae%10 end;if w[C]==nil then w[C]=af;x=x+1 end end;return f:buildFromTable(u,w,y)end else error("[XAF Error] Invalid BigNumber object - use instance(s) of this class only")end end end;g.absoluteValue=function(self)local _=f.decimalDigits;local a0=f.integerDigits;local y=0;return f:buildFromTable(_,a0,y)end;g.add=function(self,Y)assert(type(Y)=="table","[XAF Utility] Expected TABLE as argument #1")if Y.returnValue==nil then error("[XAF Error] Invalid BigNumber object - use instance(s) of this class only")else local ac=g:absoluteValue()local ad=Y:absoluteValue()local ag=g:getNumberSign()local ah=Y:getNumberSign()if ad and ah then if ag==0 and ah==0 then local ai=f:rawAdd(Y)local aj=0;ai:setNumberSign(aj)return ai elseif ag==1 and ah==1 then local ai=f:rawAdd(Y)local aj=1;ai:setNumberSign(aj)return ai else local ai=f:rawSubtract(Y)local aj=nil;if ac:isEqual(ad)==true then aj=0 elseif ac:isGreater(ad)==true then aj=ag elseif ac:isLower(ad)==true then aj=ah end;ai:setNumberSign(aj)return ai end else error("[XAF Error] Invalid BigNumber object - use instance(s) of this class only")end end end;g.ceiling=function(self)local ak=d:new('1')local W=f.decimalLength;local a0=f.integerDigits;local a1=g:getNumberSign()local ai=f:buildFromTable({},a0,a1)if W>0 then if a1==0 then ai=ai:add(ak)end end;return ai end;g.divide=function(self,Y)assert(type(Y)=="table","[XAF Utility] Expected TABLE as argument #1")if Y.returnValue==nil then error("[XAF Error] Invalid BigNumber object - use instance(s) of this class only")else local ac=g:absoluteValue()local ad=Y:absoluteValue()local ak=d:new('1')local ag=g:getNumberSign()local ah=Y:getNumberSign()local al=nil;local am=0;local an='0'if ad and ah then if ad:getValue()=='0'then error("[XAF Error] BigNumber divisor must not be equal to zero (division by zero)")else local ao=ad:returnValue()local ap=ao.decimalLength;local aq=1;local Z={}if ap>0 then ac=ac:shiftCommaRightwise(ap)ad=ad:shiftCommaRightwise(ap)end;local ar=ac:returnValue()local as=ar.decimalDigits;local at=ar.decimalLength;local au=ar.integerDigits;local av=ar.integerLength;for C=av,1,-1 do table.insert(Z,au[C])end;for C=1,at do table.insert(Z,as[C])end;local z=false;local aw=d:new('0')local ax=nil;local ay=nil;local az=0;local aA=g:getMaxPrecision()local aB=tostring(Z[1])local ai=d:new(aB)while az<aA do if ai:isEqual(ad)==true then ax=d:new('1')an=an..'1'elseif ai:isGreater(ad)==true then ax=d:new('0')ay=ai:absoluteValue()while not ay:isLower(ad)==true do ax=ax:add(ak)ay=ay:subtract(ad)end;an=an..ax:getValue()elseif ai:isLower(ad)==true then ax=d:new('0')an=an..'0'end;aq=aq+1;numberDigit=Z[aq]==nil and 0 or Z[aq]aw=ax:multiply(ad)az=z==true and az+1 or az;if aq-1==av then z=true;an=an..f.separatorDecimal end;ai=ai:subtract(aw)aB=ai:getValue()..numberDigit;ai=d:new(aB)end end;am=ag==ah and 0 or 1;al=d:new(an)al:setNumberSign(am)return al else error("[XAF Error] Invalid BigNumber object - use instance(s) of this class only")end end end;g.floor=function(self)local ak=d:new('1')local W=f.decimalLength;local a0=f.integerDigits;local a1=g:getNumberSign()local ai=f:buildFromTable({},a0,a1)if W>0 then if a1==1 then ai=ai:subtract(ak)end end;return ai end;g.getMaxPrecision=function(self)return f.decimalPrecisionMax end;g.getNumberSign=function(self)return f.numberSign end;g.getObjectValue=function(self)local _=f.decimalDigits;local a0=f.integerDigits;local a1=f.numberSign;local aC=f:buildFromTable(_,a0,a1)return aC end;g.getPrecision=function(self)return f.decimalPrecision end;g.getThousandsSeparators=function(self)local aD=f.separatorThousandsInteger;local aE=f.separatorThousandsDecimal;return aD,aE end;g.getValue=function(self)local _=f.decimalDigits;local W=f.decimalLength;local aF=f.decimalPrecision==-1 and W or f.decimalPrecision;local a0=f.integerDigits;local X=f.integerLength;local a1=f.numberSign;local aG=''if a1==1 then aG=aG..'-'end;for C=X,1,-1 do if C%3==0 then aG=aG..f.separatorThousandsInteger end;aG=aG..a0[C]end;if W>0 and aF>0 then aG=aG..f.separatorDecimal;for C=1,W do aF=aF-1;aG=aG.._[C]if C%3==0 then aG=aG..f.separatorThousandsDecimal end;if aF==0 then break end end end;if a1==0 and string.sub(aG,1,1)==' 'then aG=string.sub(aG,2)elseif a1==1 and string.sub(aG,2,2)==' 'then aG='-'..string.sub(aG,3)end;if string.sub(aG,-1)==' 'then aG=string.sub(aG,1,-2)end;if aF>0 then aG=W==0 and aG..f.separatorDecimal or aG;aG=aG..string.rep('0',aF)end;return aG end;g.getValueRadix=function(self,H)assert(type(H)=="number","[XAF Utility] Expected NUMBER as argument #1")local aH=d:new('0')local aI=0;local I=f.radixMaximumValue;local J=f.radixMinimumValue;local K=f.radixCharacterTable;local L=d:new(tostring(H))if b:checkInteger(H)==true and H>=J and H<=I then local aJ=g:absoluteValue()local aK=aJ:floor()local aL=aJ:subtract(aK)local aM=d:new('1')local aq=0;local aN=''local t=''local a1=g:getNumberSign()if aK:isEqual(aH)==0 then t=t..'0'else while aK:isEqual(aH)==false do aM=aK:modulo(L)aK=aK:divide(L)aK=aK:floor()aN=K[tonumber(aM:getValue())+1]t=aN..t;aq=aq+1;if aq%3==0 then t=f.separatorThousandsInteger..t end end end;if aL:isEqual(aH)==false then t=t..f.separatorDecimal;aq=0;while aI<f.decimalPrecisionMax and aL:isEqual(aH)==false do aL=aL:multiply(L)aM=aL:floor()aL=aL:subtract(aM)aN=K[tonumber(aM:getValue())+1]t=t..aN;aq=aq+1;aI=aI+1;if aq%3==0 then t=t..f.separatorThousandsDecimal end end end;if a1==0 and string.sub(t,1,1)==' 'then t=string.sub(t,2)elseif a1==1 and string.sub(t,2,2)==' 'then t='-'..string.sub(t,3)end;if string.sub(t,-1)==' 'then t=string.sub(t,1,-2)end;if a1==1 then t='-'..t end;return t else error("[XAF Error] Invalid BigNumber radix value, must be integer in range from "..J.." to "..I)end end;g.greatestCommonDivisor=function(self,Y)assert(type(Y)=="table","[XAF Utility] Expected TABLE as argument #1")if Y.returnValue==nil then error("[XAF Error] Invalid BigNumber object - use instance(s) of this class only")else local ac=g:absoluteValue()local ad=Y:absoluteValue()local aH=d:new('0')local ai=ac:getObjectValue()local aO=nil;if ad then if ac:isInteger()==false or ad:isInteger()==false then error("[XAF Error] Greatest common divisor must be calculated on integer BigNumbers")else while ad:isEqual(aH)==false do aO=ai:modulo(ad)ai=ad:getObjectValue()ad=aO:getObjectValue()end;return ai end else error("[XAF Error] Invalid BigNumber object - use instance(s) of this class only")end end end;g.isEqual=function(self,Y)assert(type(Y)=="table","[XAF Utility] Expected TABLE as argument #1")if Y.returnValue==nil then error("[XAF Error] Invalid BigNumber object - use instance(s) of this class only")else local Z=Y:returnValue()local _=Z.decimalDigits;local W=Z.decimalLength;local a0=Z.integerDigits;local X=Z.integerLength;local a1=Z.numberSign;if _ and W and a0 and X and a1 then if f.numberSign~=a1 then return false elseif f.integerLength~=X then return false elseif f.decimalLength~=W then return false else for C=X,1,-1 do local aa=f.integerDigits[C]local ab=a0[C]if aa~=ab then return false end end;for C=1,W do local a5=f.decimalDigits[C]local a6=_[C]if a5~=a6 then return false end end end;return true else error("[XAF Error] Invalid BigNumber object - use instance(s) of this class only")end end end;g.isGreater=function(self,Y)assert(type(Y)=="table","[XAF Utility] Expected TABLE as argument #1")if Y.returnValue==nil then error("[XAF Error] Invalid BigNumber object - use instance(s) of this class only")else local Z=Y:returnValue()local _=Z.decimalDigits;local W=Z.decimalLength;local a0=Z.integerDigits;local X=Z.integerLength;local a1=Z.numberSign;if _ and W and a0 and X and a1 then if g:isEqual(Y)==true then return false elseif f.numberSign~=a1 then return f.numberSign<a1 elseif f.integerLength~=X then if f.numberSign==0 then return f.integerLength>X else return f.integerLength<X end else local a2=f.integerLength>X and f.integerLength or X;local a3=f.decimalLength>W and f.decimalLength or W;for C=a2,1,-1 do local aa=f.integerDigits[C]==nil and 0 or f.integerDigits[C]local ab=a0[C]==nil and 0 or a0[C]if aa~=ab then if f.numberSign==0 then return aa>ab else return aa<ab end end end;for C=1,a3 do local a5=f.decimalDigits[C]==nil and 0 or f.decimalDigits[C]local a6=_[C]==nil and 0 or _[C]if a5~=a6 then if f.numberSign==0 then return a5>a6 else return a5<a6 end end end end;return true else error("[XAF Error] Invalid BigNumber object - use instance(s) of this class only")end end end;g.isInteger=function(self)local aP=g:floor()local aQ=g:ceiling()local aR=aP:isEqual(aQ)return aR end;g.isLower=function(self,Y)assert(type(Y)=="table","[XAF Utility] Expected TABLE as argument #1")if Y.returnValue==nil then error("[XAF Error] Invalid BigNumber object - use instance(s) of this class only")else local Z=Y:returnValue()local _=Z.decimalDigits;local W=Z.decimalLength;local a0=Z.integerDigits;local X=Z.integerLength;local a1=Z.numberSign;if _ and W and a0 and X and a1 then if g:isEqual(Y)==true then return false elseif f.numberSign~=a1 then return f.numberSign>a1 elseif f.integerLength~=X then if f.numberSign==0 then return f.integerLength<X else return f.integerLength>X end else local a2=f.integerLength>X and f.integerLength or X;local a3=f.decimalLength>W and f.decimalLength or W;for C=a2,1,-1 do local aa=f.integerDigits[C]==nil and 0 or f.integerDigits[C]local ab=a0[C]==nil and 0 or a0[C]if aa~=ab then if f.numberSign==0 then return aa<ab else return aa>ab end end end;for C=1,a3 do local a5=f.decimalDigits[C]==nil and 0 or f.decimalDigits[C]local a6=_[C]==nil and 0 or _[C]if a5~=a6 then if f.numberSign==0 then return a5<a6 else return a5>a6 end end end end;return true else error("[XAF Error] Invalid BigNumber object - use instance(s) of this class only")end end end;g.isNatural=function(self,aS)local aP=g:floor()local aQ=g:ceiling()local aT=d:new('-1')local aH=d:new('0')local aR=aP:isEqual(aQ)local aU=aR and g:isGreater(aT)if aS==true then aU=aU and g:isGreater(aH)end;return aU end;g.lowestCommonMultiple=function(self,Y)assert(type(Y)=="table","[XAF Utility] Expected TABLE as argument #1")if Y.returnValue==nil then error("[XAF Error] Invalid BigNumber object - use instance(s) of this class only")else local ac=g:absoluteValue()local ad=Y:absoluteValue()if ad then if ac:isInteger()==false or ad:isInteger()==false then error("[XAF Error] Lowest common multiple must be calculates on integer BigNumbers")else local aV=ac:greatestCommonDivisor(ad)local aO=ac:multiply(ad)local ai=aO:divide(aV)return ai end else error("[XAF Error] Invalid BigNumber object - use instance(s) of this class only")end end end;g.modularAdd=function(self,Y,aW)assert(type(Y)=="table","[XAF Utility] Expected TABLE as argument #1")assert(type(aW)=="table","[XAF Utility] Expected TABLE as argument #2")if Y.returnValue==nil then error("[XAF Error] Invalid BigNumber object - use instance(s) of this class only")elseif aW.returnValue==nil then error("[XAF Error] Invalid BigNumber (modulus) object - use instance(s) of this class only")else if g:isInteger()==false or Y:isInteger()==false then error("[XAF Error] BigNumber modular operations require both numbers to be integer")elseif aW:isNatural(false)==false then error("[XAF Error] BigNumber modulus must be natural number (including zero)")else local aX=g:modulo(aW)local aY=Y:modulo(aW)local aZ=aX:add(aY)local a_=aZ:modulo(aW)return a_ end end end;g.modularInverse=function(self,aW)assert(type(aW)=="table","[XAF Utility] Expected TABLE as argument #1")if aW.returnValue==nil then error("[XAF Error] Invalid BigNumber (modulus) object - use instance(s) of this class only")else if g:isInteger()==false then error("[XAF Error] BigNumber modular inversion requires this number to be integer")elseif aW:isNatural(false)==false then error("[XAF Error] BigNumber modulus must be natural number (including zero)")else local aT=d:new('-1')local ak=d:new('1')local b0=ak:getObjectValue()if g:greatestCommonDivisor(aW):isEqual(ak)==true then while b0:isEqual(aW)==false do local a_=b0:subtract(ak)local b1=g:multiply(a_)local b2=b1:modulo(aW)if b2:isEqual(ak)==true then return a_ else b0=b0:add(ak)end end else return aT end end end end;g.modularMultiply=function(self,Y,aW)assert(type(Y)=="table","[XAF Utility] Expected TABLE as argument #1")assert(type(aW)=="table","[XAF Utility] Expected TABLE as argument #2")if Y.returnValue==nil then error("[XAF Error] Invalid BigNumber object - use instance(s) of this class only")elseif aW.returnValue==nil then error("[XAF Error] Invalid BigNumber (modulus) object - use instance(s) of this class only")else if g:isInteger()==false or Y:isInteger()==false then error("[XAF Error] BigNumber modular operations require both numbers to be integer")elseif aW:isNatural(false)==false then error("[XAF Error] BigNumber modulus must be natural number (including zero)")else local aX=g:modulo(aW)local aY=Y:modulo(aW)local b1=aX:multiply(aY)local a_=b1:modulo(aW)return a_ end end end;g.modularPower=function(self,b3,aW)assert(type(b3)=="number","[XAF Utility] Expected NUMBER as argument #1")assert(type(aW)=="table","[XAF Utility] Expected TABLE as argument #2")if aW.returnValue==nil then error("[XAF Error] Invalid BigNumber (modulus) object - use instance(s) of this class only")else if g:isInteger()==false then error("[XAF Error] BigNumber modular exponentiation requires this number to be integer")elseif b:checkNatural(b3,false)==false then error("[XAF Error] BigNumber modular exponentiation requires natural exponent (including zero)")elseif aW:isNatural(false)==false then error("[XAF Error] BigNumber modulus must be natural number (including zero)")else local ak=d:new('1')local aH=d:new('0')local a_=ak:getObjectValue()local b2=nil;if aW:isEqual(ak)==true then return aH else for C=1,b3 do b2=g:multiply(a_)a_=b2:modulo(aW)end;return a_ end end end end;g.modularSubtract=function(self,Y,aW)assert(type(Y)=="table","[XAF Utility] Expected TABLE as argument #1")assert(type(aW)=="table","[XAF Utility] Expected TABLE as argument #2")if Y.returnValue==nil then error("[XAF Error] Invalid BigNumber object - use instance(s) of this class only")elseif aW.returnValue==nil then error("[XAF Error] Invalid BigNumber (modulus) object - use instance(s) of this class only")else if g:isInteger()==false or Y:isInteger()==false then error("[XAF Error] BigNumber modular operations require both numbers to be integer")elseif aW:isNatural(false)==false then error("[XAF Error] BigNumber modulus must be natural number (including zero)")else local aX=g:modulo(aW)local aY=Y:modulo(aW)local b4=aX:subtract(aY)local a_=b4:modulo(aW)return a_ end end end;g.modulo=function(self,Y)assert(type(Y)=="table","[XAF Utility] Expected TABLE as argument #1")if Y.returnValue==nil then error("[XAF Error] Invalid BigNumber object - use instance(s) of this class only")else if g:isInteger()==true and Y:isInteger()==true then local b5=g:divide(Y)local b6=b5:floor()local b7=Y:multiply(b6)local b8=g:subtract(b7)return b8 else error("[XAF Error] BigNumber modulo requires both values to be integer")end end end;g.multiply=function(self,Y)assert(type(Y)=="table","[XAF Utility] Expected TABLE as argument #1")if Y.returnValue==nil then error("[XAF Error] Invalid BigNumber object - use instance(s) of this class only")else local ac=g:absoluteValue()local ad=Y:absoluteValue()local ag=g:getNumberSign()local ah=Y:getNumberSign()local b9=nil;local ba=nil;if ad and ah then local bb={}local bc={}local bd={}local be=f:buildFromTable({},{0},0)b9=ac:isGreater(ad)==true and ac or ad;ba=ac:isGreater(ad)==true and ad or ac;local bf=b9:returnValue()local bg=bf.decimalDigits;local bh=bf.decimalLength;local bi=bf.integerDigits;local bj=bf.integerLength;local bk=ba:returnValue()local bl=bk.decimalDigits;local bm=bk.decimalLength;local bn=bk.integerDigits;local bo=bk.integerLength;for C=bh,1,-1 do table.insert(bb,bg[C])end;for C=1,bj do table.insert(bb,bi[C])end;for C=bm,1,-1 do table.insert(bc,bl[C])end;for C=1,bo do table.insert(bc,bn[C])end;for C=1,#bc do local a4=0;local bp=0;local bq=0;local br=0;bd[C]={}for G=1,#bb do bq=bc[C]*bb[G]+a4;br=bq/10;bp=bq%10;a4=math.floor(br)table.insert(bd[C],bp)end;if a4>0 then table.insert(bd[C],a4)end;for G=1,C-1 do table.insert(bd[C],1,0)end;bd[C]=f:buildFromTable({},bd[C],0)end;for C=1,#bd do be=be:add(bd[C])end;local ai=nil;local bs=be:returnValue()local bt={}local bu=bh+bm;local bv=bs.integerDigits;local bw=ag==ah and 0 or 1;for C=1,bu do local bx=table.remove(bv,1)local by=bx==nil and 0 or bx;table.insert(bt,1,by)end;ai=f:buildFromTable(bt,bv,bw)return ai else error("[XAF Error] Invalid BigNumber object - use instance(s) of this class only")end end end;g.power=function(self,b3)assert(type(b3)=="number","[XAF Utility] Expected NUMBER as argument #1")if b:checkInteger(b3)==true then local ak=d:new('1')local bz=math.abs(b3)local bA=g:getObjectValue()local bB=ak:getObjectValue()local bC=nil;if b3==0 then return ak else while bz>1 do if bz%2==0 then bA=bA:multiply(bA)bz=bz/2 else bB=bA:multiply(bB)bA=bA:multiply(bA)bz=(bz-1)/2 end end;if b3<0 then ak:setMaxPrecision(g:getMaxPrecision())bC=bA:multiply(bB)bC=ak:divide(bC)else bC=bA:multiply(bB)end;return bC end else error("[XAF Error] Invalid BigNumber power exponent - required integer value")end end;g.returnValue=function(self)return{["decimalDigits"]=f.decimalDigits,["decimalLength"]=f.decimalLength,["integerDigits"]=f.integerDigits,["integerLength"]=f.integerLength,["numberSign"]=f.numberSign}end;g.rootCube=function(self)local ac=g:absoluteValue()local bD=d:new('3')local bE=d:new('2')local bF=math.pow(ac:getValue(),1/3)local bG=(math.ceil(bF)+math.floor(bF))/2;local bH=d:new(tostring(bG))local bI=g:getMaxPrecision()local bJ=bH:getObjectValue()local bK=g:getObjectValue()local bL=nil;local bM=nil;bK:setMaxPrecision(bI)repeat bJ=bH:getObjectValue()bL=bJ:multiply(bE)bM=bL:add(bK:divide(bJ:power(2)))bH=bM:divide(bD)until f:checkPrecision(bJ,bH,bI)==true;local W=f.decimalLength;local X=f.integerLength;local bN=W>X and W or X;for C=1,bN do bJ=bH:getObjectValue()bL=bJ:multiply(bE)bM=bL:add(bK:divide(bJ:power(2)))bH=bM:divide(bD)end;bH:setNumberSign(g:getNumberSign())bH:trimDecimal(bI)return bH end;g.rootFourth=function(self)if g:getNumberSign()==1 then error("[XAF Error] Attempt to calculate fourth degree root of negative number")else local bD=d:new('4')local bE=d:new('3')local bF=math.pow(g:getValue(),1/4)local bG=(math.ceil(bF)+math.floor(bF))/2;local bH=d:new(tostring(bG))local bI=g:getMaxPrecision()local bJ=bH:getObjectValue()local bK=g:getObjectValue()local bL=nil;local bM=nil;bK:setMaxPrecision(bI)repeat bJ=bH:getObjectValue()bL=bJ:multiply(bE)bM=bL:add(bK:divide(bJ:power(3)))bH=bM:divide(bD)until f:checkPrecision(bJ,bH,bI)==true;local W=f.decimalLength;local X=f.integerLength;local bN=W>X and W or X;for C=1,bN do bJ=bH:getObjectValue()bL=bJ:multiply(bE)bM=bL:add(bK:divide(bJ:power(3)))bH=bM:divide(bD)end;bH:trimDecimal(bI)return bH end end;g.rootSquare=function(self)if g:getNumberSign()==1 then error("[XAF Error] Attempt to calculate square root of negative number")else local bD=d:new('2')local bF=math.pow(g:getValue(),1/2)local bG=(math.ceil(bF)+math.floor(bF))/2;local bH=d:new(tostring(bG))local bI=g:getMaxPrecision()local bJ=bH:getObjectValue()local bK=g:getObjectValue()local bM=nil;bK:setMaxPrecision(bI)repeat bJ=bH:getObjectValue()bM=bJ:add(bK:divide(bJ))bH=bM:divide(bD)until f:checkPrecision(bJ,bH,bI)==true;local W=f.decimalLength;local X=f.integerLength;local bN=W>X and W or X;for C=1,bN do bJ=bH:getObjectValue()bM=bJ:add(bK:divide(bJ))bH=bM:divide(bD)end;bH:trimDecimal(bI)return bH end end;g.setMaxPrecision=function(self,bO)assert(type(bO)=="number","[XAF Utility] Expected NUMBER as argument #1")if b:checkNatural(bO,true)==true then f.decimalPrecisionMax=bO else error("[XAF Error] Invalid maximum precision value - must be positive natural number")end;return true end;g.setNumberSign=function(self,bP)assert(type(bP)=="number","[XAF Utility] Expected NUMBER as argument #1")if bP==0 or bP==1 then f.numberSign=bP else error("[XAF Error] Invalid BigNumber sign value - must be equal to zero '0' or one '1'")end;return true end;g.setPrecision=function(self,bO)assert(type(bO)=="number","[XAF Utility] Expected NUMBER as argument #1")if b:checkNatural(bO,false)==true or bO==-1 then f.decimalPrecision=bO else error("[XAF Error] Invalid precision value - must be natural number or equal to -1")end;return true end;g.setThousandsSeparators=function(self,bQ,bR)assert(type(bQ)=="string","[XAF Utility] Expected STRING as argument #1")assert(type(bR)=="string","[XAF Utility] Expected STRING as argument #2")f.separatorThousandsInteger=bQ;f.separatorThousandsDecimal=bR;return true end;g.shiftCommaLeftwise=function(self,n)assert(type(n)=="number","[XAF Utility] Expected NUMBER as argument #1")if b:checkNatural(n,true)==true then local Y=d:new(g:getValue())local Z=Y:returnValue()local u=Z.decimalDigits;local v=Z.decimalLength;local w=Z.integerDigits;local x=Z.integerLength;local y=Z.numberSign;local P=nil;for C=1,n do if x>1 then local bS=table.remove(w,1)table.insert(u,1,bS)v=v+1;x=x-1 else local bS=table.remove(w,1)table.insert(u,1,bS)v=v+1;w={0}x=1 end end;P=f:buildFromTable(u,w,y)return P else error("[XAF Error] Invalid shift digit count, must be natural number (except zero)")end end;g.shiftCommaRightwise=function(self,n)assert(type(n)=="number","[XAF Utility] Expected NUMBER as argument #1")if b:checkNatural(n,true)==true then local Y=d:new(g:getValue())local Z=Y:returnValue()local u=Z.decimalDigits;local v=Z.decimalLength;local w=Z.integerDigits;local x=Z.integerLength;local y=Z.numberSign;local P=nil;for C=1,n do if v>0 then local bS=table.remove(u,1)table.insert(w,1,bS)v=v-1;x=x+1 else table.insert(w,1,0)x=x+1 end end;P=f:buildFromTable(u,w,y)return P else error("[XAF Error] Invalid shift digit count, must be natural number (except zero)")end end;g.subtract=function(self,Y)assert(type(Y)=="table","[XAF Utility] Expected TABLE as argument #1")if Y.returnValue==nil then error("[XAF Error] Invalid BigNumber object - use instance(s) of this class only")else local ac=g:absoluteValue()local ad=Y:absoluteValue()local ag=g:getNumberSign()local ah=Y:getNumberSign()if ad and ah then if ag==0 and ah==1 then local ai=f:rawAdd(Y)local aj=0;ai:setNumberSign(aj)return ai elseif ag==1 and ah==0 then local ai=f:rawAdd(Y)local aj=1;ai:setNumberSign(aj)return ai else local ai=f:rawSubtract(Y)local aj=nil;if ac:isEqual(ad)==true then aj=0 elseif ac:isGreater(ad)==true then aj=ag==0 and 0 or 1 elseif ac:isLower(ad)==true then aj=ag==0 and 1 or 0 end;ai:setNumberSign(aj)return ai end else error("[XAF Error] Invalid BigNumber object - use instance(s) of this class only")end end end;g.trimDecimal=function(self,n)assert(type(n)=="number","[XAF Utility] Expected NUMBER as argument #1")if b:checkNatural(n,false)==true then if f.decimalLength>n then for C=f.decimalLength,n+1,-1 do table.remove(f.decimalDigits,C)f.decimalLength=f.decimalLength-1 end;f:normalizeNumber()return true else return false end else error("[XAF Error] Decimal digits trim count must be natural number (including zero)")end end;return{private=f,public=g}end;function d:extend()local bT=self:initialize()local f=bT.private;local g=bT.public;if self.C_INHERIT==true then return{private=f,public=g}else error("[XAF Error] Class '"..tostring(self.C_NAME).."' cannot be inherited")end end;function d:new(t,bU)local bT=self:initialize()local f=bT.private;local g=bT.public;if bU==nil then f:convertString(t)f:normalizeNumber()else f:convertStringRadix(t,bU)f:normalizeNumber()end;if f.initialExponent~=0 then local bV=f.initialExponent;local Y=nil;if f.initialExponent>0 then Y=g:shiftCommaRightwise(bV)else Y=g:shiftCommaLeftwise(-1*bV)end;local k=d:new(Y:getValue())local bW=k:returnValue()f.decimalDigits=bW.decimalDigits;f.decimalLength=bW.decimalLength;f.integerDigits=bW.integerDigits;f.integerLength=bW.integerLength;f.numberSign=bW.numberSign;f:normalizeNumber()end;if self.C_INSTANCE==true then return g else error("[XAF Error] Class '"..tostring(self.C_NAME).."' cannot be instanced")end end;return d
